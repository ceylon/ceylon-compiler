package com.redhat.ceylon.compiler.codegen;

import static com.sun.tools.javac.code.TypeTags.VOID;

import com.redhat.ceylon.compiler.util.Util;
import com.sun.tools.javac.code.Flags;
import com.sun.tools.javac.code.TypeTags;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.JCTree.JCAnnotation;
import com.sun.tools.javac.util.List;
import com.sun.tools.javac.util.ListBuffer;
import com.sun.tools.javac.util.Name;

/**
 * Builds a class for global variables. See {@link GlobalTransformer} for an overview.
 *
 * The generated class can be customized by calling methods of this class.
 */
public class AttributeBuilder {
    private final Name fieldName;

    private final JCTree.JCExpression variableType;
    private final String variableName;

    private long classFlags;

    private boolean readable = true;
    private long getterFlags;
    private JCTree.JCBlock getterBlock;

    private JCTree.JCExpression variableInit;

    private boolean writable = true;
    private long setterFlags;
    private JCTree.JCBlock setterBlock;
    
    private List<JCTree.JCAnnotation> valueAnnotations = List.nil();
    private List<JCTree.JCAnnotation> classAnnotations = List.nil();

    private boolean skipConstructor;

    private AbstractTransformer owner;

    public AttributeBuilder(AbstractTransformer owner, JCTree.JCExpression variableType, String variableName) {
        this.owner = owner;
        this.variableType = variableType;
        this.variableName = variableName;
        this.fieldName = owner.names().fromString("value");
    }

    /**
     * Generates the class and returns the generated tree.
     * @return the generated class tree, to be added to the appropriate {@link JCTree.JCCompilationUnit}.
     */
    public JCTree build() {
        ListBuffer<JCTree> defs = ListBuffer.lb();
        appendDefinitionsTo(defs);
        return owner.make().ClassDef(
                owner.make().Modifiers(classFlags, classAnnotations.prependList(owner.gen.makeAtCeylon())),
                getClassName(variableName),
                List.<JCTree.JCTypeParameter>nil(),
                null,
                List.<JCTree.JCExpression>nil(),
                defs.toList());
    }

    /**
     * Appends to <tt>defs</tt> the definitions that would go into the class generated by {@link #build()}
     * @param defs a {@link ListBuffer} to which the definitions will be appended.
     */
    public void appendDefinitionsTo(ListBuffer<JCTree> defs) {
        if (getterBlock == null) {
            defs.append(generateField());
        }

        if (readable) {
            defs.append(generateGetter());
        }

        if (writable) {
            defs.append(generateSetter());
        }
        
        if(!skipConstructor){
            // make a private constructor
            defs.append(owner.make().MethodDef(owner.make().Modifiers(Flags.PRIVATE),
                    owner.names().init,
                    owner.make().TypeIdent(VOID),
                    List.<JCTree.JCTypeParameter>nil(),
                    List.<JCTree.JCVariableDecl>nil(),
                    List.<JCTree.JCExpression>nil(),
                    owner.make().Block(0, List.<JCTree.JCStatement>nil()),
                    null));
        }
    }

    private JCTree generateField() {
        int flags = Flags.PRIVATE | Flags.STATIC;
        if (!writable) {
            flags |= Flags.FINAL;
        }

        return owner.make().VarDef(
                owner.make().Modifiers(flags),
                fieldName,
                variableType,
                variableInit
        );
    }

    private JCTree generateGetter() {
        JCTree.JCBlock body = getterBlock != null
                ? getterBlock
                : generateDefaultGetterBlock();

        return owner.make().MethodDef(
                owner.make().Modifiers(getterFlags, valueAnnotations),
                getGetterName(variableName),
                variableType,
                List.<JCTree.JCTypeParameter>nil(),
                List.<JCTree.JCVariableDecl>nil(),
                List.<JCTree.JCExpression>nil(),
                body,
                null
        );
    }

    private JCTree.JCBlock generateDefaultGetterBlock() {
        return owner.make().Block(0L, List.<JCTree.JCStatement>of(owner.make().Return(owner.make().Ident(fieldName))));
    }

    private JCTree generateSetter() {
        Name paramName = owner.names().fromString("newValue");

        JCTree.JCBlock body;
        if (getterBlock != null) {
            body = setterBlock != null ? setterBlock : createEmptyBlock();
        } else {
            body = generateDefaultSetterBlock(paramName);
        }
        return owner.make().MethodDef(
                owner.make().Modifiers(setterFlags),
                getSetterName(variableName),
                owner.make().TypeIdent(TypeTags.VOID),
                List.<JCTree.JCTypeParameter>nil(),
                List.<JCTree.JCVariableDecl>of(
                        owner.make().VarDef(owner.make().Modifiers(0, valueAnnotations), paramName, variableType, null)
                ),
                List.<JCTree.JCExpression>nil(),
                body,
                null
        );
    }

    private JCTree.JCBlock createEmptyBlock() {
        return owner.make().Block(0L, List.<JCTree.JCStatement>nil());
    }

    private JCTree.JCBlock generateDefaultSetterBlock(Name paramName) {
        return owner.make().Block(0L, List.<JCTree.JCStatement>of(
                owner.make().Exec(
                        owner.make().Assign(
                                owner.make().Ident(fieldName),
                                owner.make().Ident(paramName)))));
    }

    /**
     * Sets the modifier flags of the generated class.
     * @param classFlags the modifier flags (see {@link Flags})
     * @return this instance for method chaining
     */
    public AttributeBuilder classFlags(long classFlags) {
        this.classFlags = classFlags;
        return this;
    }
    
    public AttributeBuilder addClassFlags(long classFlags) {
        this.classFlags = this.classFlags | classFlags;
        return this;
    }

    /**
     * Sets the modifier flags of the generated getter. If no getter is generated the modifier flags will be silently
     * ignored.
     * @param getterFlags the modifier flags (see {@link Flags})
     * @return this instance for method chaining
     */
    public AttributeBuilder getterFlags(long getterFlags) {
        this.getterFlags = getterFlags;
        return this;
    }
    
    public AttributeBuilder addGetterFlags(long getterFlags) {
        this.getterFlags = this.getterFlags | getterFlags;
        return this;
    }

    /**
     * Sets the code block to use for the generated getter. If no getter is generated the code block will be
     * silently ignored.
     * @param getterBlock a code block
     * @return this instance for method chaining
     */
    public AttributeBuilder getterBlock(JCTree.JCBlock getterBlock) {
        this.getterBlock = getterBlock;
        return this;
    }

    /**
     * Sets the modifier flags of the generated setter. If no setter is generated the modifier flags will be silently
     * ignored.
     * @param setterFlags the modifier flags (see {@link Flags})
     * @return this instance for method chaining
     */
    public AttributeBuilder setterFlags(long setterFlags) {
        this.setterFlags = setterFlags;
        return this;
    }
    
    public AttributeBuilder addSetterFlags(long setterFlags) {
        this.setterFlags = this.setterFlags | setterFlags;
        return this;
    }

    /**
     * Sets the code block to use for the generated setter. If no setter is generated the code block will be
     * silently ignored.
     * @param setterBlock a code block
     * @return this instance for method chaining
     */
    public AttributeBuilder setterBlock(JCTree.JCBlock setterBlock) {
        this.setterBlock = setterBlock;
        return this;
    }

    /**
     * Causes the generated global to be immutable. The <tt>value</tt> field is declared <tt>final</tt> and no
     * setter is generated.
     * @return this instance for method chaining
     */
    public AttributeBuilder immutable() {
        this.writable = false;
        return this;
    }

    /**
     * The <tt>value</tt> field will be declared with the initial value given by the parameter
     * @param initialValue the initial value of the global.
     * @return this instance for method chaining
     */
    public AttributeBuilder initialValue(JCTree.JCExpression initialValue) {
        this.variableInit = initialValue;
        return this;
    }

    /**
     * Applies the given <tt>valueAnnotations</tt> to the getter method and to the parameter of the setter method.
     * @param valueAnnotations the annotations to apply.
     * @return this instance for method chaining
     */
    public AttributeBuilder valueAnnotations(List<JCTree.JCAnnotation> valueAnnotations) {
        this.valueAnnotations = valueAnnotations;
        return this;
    }

    public AttributeBuilder classAnnotations(List<JCTree.JCAnnotation> classAnnotations) {
        this.classAnnotations = classAnnotations;
        return this;
    }

    public AttributeBuilder skipConstructor() {
        this.skipConstructor = true;
        return this;
    }
    
    private Name getClassName(String variableName) {
        return owner.gen.quoteName(variableName);
    }

    private Name getGetterName(String variableName) {
        return owner.names().fromString(Util.getGetterName(variableName));
    }

    private Name getSetterName(String variableName) {
        return owner.names().fromString(Util.getSetterName(variableName));
    }
}